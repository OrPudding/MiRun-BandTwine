<template>
	<!--主容器-->
	<div class="main-container">
		<!--独立侧边栏菜单-->
		<div if="{{ showMenu }}" class="sidebar-menu">
			<div class="menu-header" onclick="toggleMenu">
				<text class="menu-title">菜单</text>
			</div>
			<!--标签页导航-->
			<div class="menu-tabs">
				<text
					class="menu-tab {{ activeTab === 'status' ? 'active-tab' : '' }}"
					onclick="switchTab('status')"
				>
					状态
				</text>
				<text
					class="menu-tab {{ activeTab === 'settings' ? 'active-tab' : '' }}"
					onclick="switchTab('settings')"
				>
					更多
				</text>
			</div>
			<!--标签页内容容器-->
			<div class="tab-content-container">
				<!--状态标签页-->
				<scroll
					if="{{ activeTab === 'status' }}"
					class="menu-scroll"
					scroll-y="true"
				>
					<div class="status-section" for="{{ showVars }}">
						<div if="{{ !$item.isTitle }}" class="inventory-card">
							<text class="inventory-item">
								{{ $item.desc }}: {{ $item.value }}
							</text>
						</div>
						<div if="{{ $item.isTitle }}" class="inventory-container">
							<text class="inventory-title">{{ $item.text }}</text>
						</div>
					</div>
				</scroll>
				<!--设置标签页-->
				<div if="{{ activeTab === 'settings' }}" class="settings-section">
					<div class="setting-item">
						<text style="font-size: 24px; color: #fff">调试模式</text>
						<switch
							checked="{{ debugMode }}"
							style="margin-left: 20px; height: 30px; width: 60px"
							onchange="toggleDebugMode"
						/>
					</div>
					<div class="menu-action" onclick="backToHome">
						<text
							style="
								font-size: 28px;
								font-weight: bold;
								text-align: center;
								border-radius: 12px;
								color: #e74c3c;
							"
						>
							返回主菜单
						</text>
					</div>
				</div>
			</div>
		</div>
		<!--内容滚动区域-->
		<scroll id="scrollId" class="content-scroll" scroll-y="true">
			<!--顶部时间显示-->
			<!--感谢wuhaiqi提供的弧形时间,由OrPudding移植圆表-->
			<div class="header" @click="toggleMenu">
				<text class="time" style="left: 40px;">
					{{ time[0] }}
				</text>
				<text class="time" style="left: 20px;">
					{{ time[1] }}
				</text>
				<text class="time" style="left: 0px;">{{ ":" }}</text>
				<text class="time" style="left: -20px;">
					{{ time[2] }}
				</text>
				<text class="time" style="left: -40px;">
					{{ time[3] }}
				</text>
				<text class="pagetitle">{{ title }}</text>
			</div>
			<!--内容区域-->
			<div class="scene">
				<block for="{{ segments }}">
					<text if="$item.type === 'text'" class="normal-text">
						{{ $item.content }}
					</text>
					<div
						if="$item.type === 'newline'"
						style="width: 100%; height: 6px"
					></div>
					<div
						if="$item.type === 'link-container'"
						class="link-container"
						onclick="selectOption($item.linkIndex)"
					>
						<block for="{{ $item.children }}">
							<text if="$item.type === 'text'" class="link-text">
								{{ $item.content }}
							</text>
							<image
								if="$item.type === 'image'"
								src="{{ $item.path }}"
								style="width:{{ $item.width }}px"
								data-index="{{ $idx }}"
								onerror="handleImageError"
							/>
						</block>
					</div>
					<text if="$item.type === 'disabled'" class="disabled-text">
						{{ $item.content }}
					</text>
					<text if="$item.type === 'error'" class="error-text">
						[ERR]{{ $item.content }}
					</text>
				</block>
			</div>
		</scroll>
	</div>
</template>
<script>
import router from "@system.router";
import storage from "@system.storage";
import prompt from "@system.prompt";

import gameData from "../../common/game-data.json";
export default {
	private: {
		time: ["0", "0", "0", "0"],
		debugMode: false,
		timer: null,
		showMenu: false,
		activeTab: "status",
		saveSlots: [
			{ time: "" },
			{ time: "" },
			{ time: "" },
			{ time: "" },
			{ time: "" },
		],
		currentNodeId: "start",
		segments: [],
		currentLinks: [],
		STORAGE_KEY: "game_state",
		showVars: [],
		listeners: [],
		vars: {},
		hourChanged: false,
		dayChanged: false,
		currentNode: null,
		title: "114514",
	},
	protected: { loadSlot: null },
	onInit() {
		router.clear();
		this.deleteSaveSlot(0);
		this.initVariableSystem();
		this.updateShowVars();
		this.loadSaveSlots();
		this.loadNode(this.currentNodeId);
		this.debugLog("游戏初始化完成");
	},
	onReady() {
		this.scrollTo();
	},
	onDestroy() {
		clearInterval(this.timer);
	},
	onBackPress() {
		this.toggleMenu();
		return true;
	},
	updateGameTime() {
		const formattedTime = this.getFormattedTime();
		const [hours, minutes] = formattedTime.split(":");
		this.time = [hours[0], hours[1], minutes[0], minutes[1]];
	},
	scrollTo() {
		this.$element("scrollId").scrollTo({ top: 0, left: 0 });
	},
	toggleMenu() {
		this.showMenu = !this.showMenu;
		if (this.showMenu) {
			this.activeTab = "status";
			this.loadSaveSlots();
		}
	},
	switchTab(tabName) {
		this.activeTab = tabName;
	},
	backToHome() {
		router.replace({ uri: "pages/index" });
	},
	toggleDebugMode(e) {
		this.debugMode = e.checked;
		this.showToast(`调试模式${e.checked ? "开启" : "关闭"}`);
	},
	selectOption(linkIndex) {
		if (!this.validateLinkIndex(linkIndex)) {
			return this.showToast("无效选项");
		}
		const link = this.currentLinks[linkIndex];
		const jumpTriggered = this.executeActions(link.actions || []);
		if (!jumpTriggered) {
			let targetNode = this.processLinkTarget(link);
			if (link.incom) this.processIncomingData(link.incom);
			this.timer = setTimeout(() => {
				this.debugLog(`选择选项:${linkIndex}${targetNode}`);
				this.loadNode(targetNode);
			}, 150);
		}
	},
	handleImageError(e) {
		const index = parseInt(e.target.dataset.index);
		if (isNaN(index)) return;
		const segment = this.segments[index];
		if (segment?.type === "image") {
			this.pushErrorSegment(`图片加载失败:${segment.path}`);
			this.$page.$forceUpdate();
		}
	},
	loadNode(nodeId, fromJump = false) {
		console.log(`[节点加载] 开始: ${nodeId}`, { fromJump });

		// 异步队列控制
		if (this._isLoading) {
			setTimeout(() => this.loadNode(nodeId, fromJump), 50);
			return;
		}

		this._isLoading = true;
		try {
			// 1. 检查监听器跳转
			const jumpFromListener = this.beforeLoadNode(nodeId);
			if (jumpFromListener) {
				console.log(`[监听器跳转] ${nodeId} -> ${jumpFromListener}`);
				setTimeout(() => {
					this._isLoading = false;
					this.loadNode(jumpFromListener, true);
				}, 10);
				return;
			}

			// 2. 加载节点内容
			const node = gameData.nodes[nodeId];
			if (!node) throw new Error(`节点不存在: ${nodeId}`);

			// 3. 执行节点动作（同步执行）
			console.log(`[节点动作] 开始执行`);
			const shouldJump = this.executeActions(node.actions || []);

			if (shouldJump) {
				console.log("[节点动作] 已触发跳转");
				this._isLoading = false;
				return;
			}

			// 4. 更新UI状态
			this.currentNode = node;
			this.currentNodeId = nodeId;
			this.currentLinks = node.links || [];
			this.parseTextWithLinks(node.text);
			this.title = node.title || "未命名节点";

			// 5. 更新时间显示
			this.updateGameTime();

			// 6. 确保UI更新
			this.$nextTick(() => {
				this.scrollTo();
				this._isLoading = false;
				console.log(`[节点加载] 完成: ${nodeId}`);
			});
		} catch (e) {
			this._isLoading = false;
			console.error("[节点加载异常]", e);
			this.handleError("节点加载错误", e);
		}
	},
	parseTextWithLinks(text) {
		this.segments = [];
		if (!text) return;

		// 新增文本缓冲区
		let textBuffer = "";
		const flushTextBuffer = () => {
			if (textBuffer.length > 0) {
				this.segments.push({ type: "text", content: textBuffer });
				textBuffer = "";
			}
		};

		// 修改正则表达式以捕获换行符
		const regex = /(\{\w+\.?[\w\.]*\}|\n)/g;
		let lastIndex = 0;
		let match;

		while ((match = regex.exec(text)) !== null) {
			// 处理匹配前的普通文本
			if (match.index > lastIndex) {
				textBuffer += text.substring(lastIndex, match.index);
			}

			const matched = match[1];
			if (matched === "\n") {
				// 遇到换行符时提交缓冲区并添加换行segment
				flushTextBuffer();
				this.segments.push({ type: "newline" });
			} else if (matched.startsWith("{cond.")) {
				// 解析条件文本并加入缓冲区
				const condValue = this.resolveCondition(matched.replace(/\{|\}/g, ""));
				textBuffer += condValue;
			} else if (matched.startsWith("{random.")) {
				// 解析随机文本并加入缓冲区
				const randomValue = this.resolveValue(matched.replace(/\{|\}/g, ""));
				textBuffer += randomValue;
			} else if (matched.startsWith("{var.")) {
				// 新增变量处理
				const varValue = this.resolveValue(matched.replace(/\{|\}/g, ""));
				textBuffer += varValue;
			} else if (/^\{\d+\}$/.test(matched)) {
				// 遇到链接标记时提交缓冲区
				flushTextBuffer();
				const linkId = parseInt(matched.replace(/\{|\}/g, ""));
				this.handleLinkMarker(linkId);
			} else {
				// 其他标记直接加入缓冲区
				textBuffer += matched;
			}

			lastIndex = match.index + matched.length;
		}

		// 处理剩余文本
		if (lastIndex < text.length) {
			textBuffer += text.substring(lastIndex);
		}
		flushTextBuffer();
	},
	resolveCondition(path) {
		const parts = path.split(".");
		if (parts[0] !== "cond") return `[无效条件标记:${path}]`;
		const groupName = parts[1];
		const conditionGroup = this.currentNode?.conds?.[groupName];
		if (!conditionGroup) return `[条件组不存在:${groupName}]`;
		for (const item of conditionGroup) {
			if (item.condition) {
				try {
					const conditionResult = this.parseExpression(item.condition);
					if (conditionResult) {
						return item.text || "";
					}
				} catch (e) {
					this.debugLog(`条件解析失败:${item.condition}`, e);
					return `[条件错误:${item.condition}]`;
				}
			} else {
				return item.text || "";
			}
		}
		return `[无匹配条件:${path}]`;
	},
	initVariableSystem() {
		this.vars = JSON.parse(JSON.stringify(gameData.variables || {}));
		this.debugLog("变量系统初始化");
	},
	parseVariablePath(path) {
		if (!path.startsWith("var.")) {
			this.debugLog(`无效变量路径:${path}`);
			return null;
		}
		return path.substring(4).split(".");
	},
	getVariable(path) {
		const parts = path.split(".");
		if (parts[0] !== "var") return undefined;
		let value = this.vars;
		for (let i = 1; i < parts.length; i++) {
			if (value === null || value === undefined) return undefined;
			value = value[parts[i]];
		}
		return value;
	},
	// 在 setVariable 方法中添加健康检测
	setVariable(path, value) {
		console.log(`[变量修改开始] ${path} = ${JSON.stringify(value)}`); // 调试日志
		const parts = this.parseVariablePath(path);
		if (!parts) return false;

		try {
			let current = this.vars;
			for (let i = 0; i < parts.length - 1; i++) {
				const part = parts[i];
				if (!current[part] || typeof current[part] !== "object") {
					current[part] = {};
				}
				current = current[part];
			}

			const lastKey = parts[parts.length - 1];
			const oldValue = current[lastKey];
			current[lastKey] = this.resolveValue(value);

			console.log(
				`[变量修改成功] ${path}: ${JSON.stringify(
					oldValue
				)} -> ${JSON.stringify(current[lastKey])}`
			); // 调试日志
			this.updateShowVars();
			return true;
		} catch (e) {
			console.error(`[变量修改失败] ${path}:`, e); // 调试日志
			return false;
		}
	},
	updateShowVars() {
		const formatValue = (value) => {
			if (typeof value === "boolean") return value ? "是" : "否";
			if (Array.isArray(value)) return value.join(", ") || "空";
			return value !== undefined ? value : "无数据";
		};

		// 只保留基础属性
		this.showVars = [
			{ type: "title", text: "基础属性" },
			{ desc: "成功率", value: this.vars.successRate },
			{ desc: "健康值", value: this.vars.health },
			{ desc: "精神值", value: this.vars.mentalHealth },
			{ desc: "技能点", value: this.vars.skillPoints },
			...(this.vars.inventory?.map((item) => ({
				desc: item,
				value: "持有",
			})) || [{ desc: "空空如也", value: "无物品" }]),
		].map((item) => ({
			...item,
			value: formatValue(item.value),
			isTitle: item.type === "title",
		}));
	},
	resolveValue(input) {
		if (typeof input !== "string") return input;
		if (input.startsWith("##") && input.endsWith("##")) {
			return input.slice(2, -2);
		}
		if (input.startsWith("var.")) {
			const value = this.getVariable(input);
			// 变量值转换为数字
			return !isNaN(value) ? Number(value) : value;
		}
		if (input.startsWith("$(") && input.endsWith(")")) {
			const result = this.parseExpression(input.slice(2, -1));
			// 添加数值类型转换
			return typeof result === "number" ? result : Number(result) || 0;
		}
		if (input.startsWith("random.")) {
			const result = this.getRandomResult(input);
			// 执行随机结果中的动作
			if (result?.actions) {
				this.$nextTick(() => {
					this.executeActions(result.actions);
				});
			}
			return result?.text || result || `[随机错误:${input}]`;
		}
		return input;
	},

	parseTextMarkers(text) {
		if (typeof text !== "string") return text;
		return text.replace(
			/\{(var\.[^}]+|random\.[^}]+|cond\.[^}]+)\}/g,
			(_, path) => {
				if (path.startsWith("cond.")) {
					return this.resolveCondition(path);
				}
				return this.resolveValue(path);
			}
		);
	},
	parseExpression(expr) {
		try {
			const varPattern = /var\.([\w.]+)/g;
			let processedExpr = expr.replace(varPattern, (_, path) => {
				const value = this.getVariable(`var.${path}`);
				return typeof value === "number" ? value : JSON.stringify(value);
			});
			const context = {
				Math: Math,
				utils: this.expressionUtils || {},
				engine: this,
				var: this.vars,
			};
			return new Function(
				"context",
				`with(context){return ${processedExpr}}`
			).call(context, context);
		} catch (e) {
			this.debugLog(`表达式解析失败:${expr}`, e);
			return false;
		}
	},
	checkCondition(condition) {
		if (condition === "hourChanged") return this.hourChanged;
		if (condition === "dayChanged") return this.dayChanged;
		if (!condition) return true;
		if (condition.startsWith("$(") && condition.endsWith(")")) {
			try {
				return !!this.parseExpression(condition.slice(2, -1));
			} catch (e) {
				this.debugLog(`条件表达式错误:${condition}`, e);
				return false;
			}
		}
		const andParts = condition.split("&&").map((s) => s.trim());
		if (andParts.length > 1)
			return andParts.every((p) => this.checkCondition(p));
		const orParts = condition.split("||").map((s) => s.trim());
		if (orParts.length > 1) return orParts.some((p) => this.checkCondition(p));
		const match = condition.match(
			/([\w.]+|'[^']*'|"[^"]*")\s*(==|!=|>|<|>=|<=)\s*(['"].*?['"]|[\w.]+)/
		);
		if (match) {
			let [, left, operator, right] = match;
			left = this.resolveValue(left);
			right = this.resolveValue(right);
			switch (operator) {
				case "==":
					return left == right;
				case "!=":
					return left != right;
				case ">":
					return left > right;
				case "<":
					return left < right;
				case ">=":
					return left >= right;
				case "<=":
					return left <= right;
			}
		}
		if (condition === "true") return true;
		if (condition === "false") return false;
		if (condition.startsWith("var.")) return !!this.getVariable(condition);
		return false;
	},
	executeActions(actions = []) {
		if (!Array.isArray(actions)) {
			console.warn("动作必须为数组", actions);
			return false;
		}

		// 健康检查（独立于动作执行）
		const healthCheck = () => {
			const health = this.getVariable("var.health");
			if (typeof health === "number" && health <= 0) {
				console.log("[健康检查] 触发死亡结局");
				this.setVariable("var.health", 100);
				setTimeout(() => this.loadNode("ending_death"), 10);
				return true;
			}
			return false;
		};

		if (healthCheck()) return true;

		let hasJump = false;
		let jumpTarget = null;

		// 分阶段执行：1.先执行所有非跳转动作 2.最后处理跳转
		for (const action of actions) {
			try {
				if (!action.type) continue;

				// 如果是跳转动作，只记录不立即执行
				if (action.type === "jump" && this.checkCondition(action.condition)) {
					console.log(`[动作执行] 跳转计划: ${action.target}`);
					hasJump = true;
					jumpTarget = action.target;
					continue;
				}

				// 执行非跳转动作
				console.log(`[动作执行] 开始: ${JSON.stringify(action)}`);
				switch (action.type) {
					case "set":
						this.setVariable(action.target, action.value);
						break;
					case "add":
						const current = parseFloat(this.getVariable(action.target)) || 0;
						const toAdd = parseFloat(this.resolveValue(action.value)) || 0;
						this.setVariable(action.target, current + toAdd);
						break;
					case "toggle":
						const currentVal = this.getVariable(action.target);
						this.setVariable(action.target, !currentVal);
						break;
					case "random":
						const result = this.getRandomResult(`random.${action.id}`);
						if (result?.actions) {
							this.executeActions(result.actions);
						}
						break;
					case "listener":
						this.addListener(action.id, action.condition, action.actions, {
							once: action.once,
						});
						break;
					default:
						console.warn("未知动作类型:", action.type);
				}
				console.log(`[动作执行] 完成: ${JSON.stringify(action)}`);
			} catch (e) {
				console.error(`[动作执行失败]`, action, e);
			}

			// 每次动作后检查健康状态
			if (healthCheck()) return true;
		}

		// 所有非跳转动作完成后处理跳转
		if (hasJump && jumpTarget) {
			console.log(`[跳转执行] 异步跳转到: ${jumpTarget}`);
			setTimeout(() => {
				try {
					this.loadNode(jumpTarget);
				} catch (e) {
					console.error("跳转失败:", e);
				}
			}, 10);
			return true;
		}

		return false;
	},

	handleLinkMarker(linkIndex) {
		if (!this.validateLinkIndex(linkIndex)) {
			return this.pushErrorSegment(`无效链接${linkIndex}`);
		}
		const link = this.currentLinks[linkIndex];
		const isActive = this.checkCondition(link.condition);

		// 创建一个容器来包裹所有内容
		const container = {
			type: "link-container",
			children: [],
			linkIndex,
			isActive,
		};

		// 处理链接文本中的emoji
		const emojiRegex = /(\p{Emoji})/gu;
		let lastPos = 0;
		let emojiMatch;

		while ((emojiMatch = emojiRegex.exec(link.text)) !== null) {
			// 添加emoji前的文本
			if (emojiMatch.index > lastPos) {
				container.children.push({
					type: "text",
					content: link.text.substring(lastPos, emojiMatch.index),
				});
			}

			// 添加emoji图片
			const emoji = emojiMatch[1];
			container.children.push({
				type: "image",
				path: `/common/images/emoji-${emoji}-32px.png`,
				width: 32,
			});

			lastPos = emojiMatch.index + emoji.length;
		}

		// 添加剩余文本
		if (lastPos < link.text.length) {
			container.children.push({
				type: "text",
				content: link.text.substring(lastPos),
			});
		}

		this.segments.push(container);
	},

	handleImageMarker(markerId) {
		const imgId = markerId.replace("img.", "");
		const currentNode = gameData.nodes[this.currentNodeId];
		if (!currentNode || !currentNode.imgs || !currentNode.imgs[imgId]) {
			return this.pushErrorSegment(`图片配置错误:${imgId}`);
		}
		const imgDef = currentNode.imgs[imgId];
		let path = imgDef.path || "";
		if (path.includes("${")) {
			try {
				path = path.replace(
					/\${(.*?)}/g,
					(_, expr) => this.parseExpression(expr)?.toString() || ""
				);
			} catch (e) {
				return this.pushErrorSegment(`图片路径表达式错误:${imgId}`);
			}
		}
		let finalPath = path;
		if (
			path &&
			!path.includes("/common/images/") &&
			!path.startsWith("/") &&
			!path.startsWith("http") &&
			!path.startsWith(".")
		) {
			finalPath = "/common/images/" + path;
		}
		this.segments.push({
			type: "image",
			path: finalPath,
			width: imgDef.width || 150,
		});
	},
	handleScriptMarker(marker) {
		this.debugLog(`脚本标记:${marker}`);
	},
	getRandomResult(markerId) {
		const randomId = markerId.replace("random.", "");
		try {
			const randoms = gameData.nodes[this.currentNodeId]?.randoms;
			if (!randoms || !randoms[randomId]) {
				this.debugLog(`随机组未定义:${randomId}`);
				return { text: `[ERROR]随机组未定义` };
			}

			const options = randoms[randomId];
			const validOptions = options.filter(
				(opt) => !opt.condition || this.checkCondition(opt.condition)
			);

			if (validOptions.length === 0) {
				this.debugLog(`无可用选项:${randomId}`);
				return { text: "[无可用选项]" };
			}

			const totalWeight = validOptions.reduce(
				(sum, o) =>
					sum + (typeof o.weight === "number" ? Math.max(0, o.weight) : 1),
				0
			);

			if (totalWeight <= 0) {
				this.debugLog(`权重错误:${randomId}`, { options: validOptions });
				return validOptions[0] || { text: "[权重错误]" };
			}

			let randomVal = Math.random() * totalWeight;
			for (const opt of validOptions) {
				randomVal -= opt.weight || 1;
				if (randomVal <= 0) {
					this.debugLog(`随机选择结果`, {
						group: randomId,
						selected: opt.text,
						hasActions: !!opt.actions,
					});
					return opt;
				}
			}

			const defaultReturn = validOptions[0] || { text: "[随机错误]" };
			this.debugLog(`随机默认返回`, defaultReturn);
			return defaultReturn;
		} catch (e) {
			this.debugLog(`随机处理失败:${randomId}`, e);
			return { text: `[ERROR]随机处理失败` };
		}
	},

	addListener(id, condition, actions = [], options = {}) {
		this.removeListener(id);
		this.listeners.push({
			id,
			condition,
			actions,
			once: options.once !== false,
			nodeId: options.nodeId || null,
			type: options.type || "general",
		});
		this.debugLog(`监听器添加:${id}`);
	},
	removeListener(id) {
		const newLength = this.listeners.filter((l) => l.id !== id).length;
		if (this.listeners.length !== newLength) {
			this.listeners = this.listeners.filter((l) => l.id !== id);
			this.debugLog(`监听器移除:${id}`);
		}
	},
	advanceTime(minutes) {
		if (typeof minutes !== "number" || minutes <= 0) return;
		const currentTime = this.getVariable("var.world.time");
		const currentDay = this.getVariable("var.world.day");
		let newTime = currentTime + minutes;
		let newDay = currentDay;
		let dayChanged = false;
		if (newTime >= 1440) {
			newDay += Math.floor(newTime / 1440);
			newTime = newTime % 1440;
			dayChanged = true;
		}
		let hourChanged = false;
		const currentHour = Math.floor(currentTime / 60);
		const newHour = Math.floor(newTime / 60);
		if (currentHour !== newHour) {
			hourChanged = true;
		}
		this.setVariable("var.world.time", newTime);
		this.setVariable("var.world.day", newDay);
		this.setVariable("var.world.formattedTime", this.formatGameTime(newTime));
		this.setVariable("var.world.timePeriod", this.getTimePeriod(newTime));
		this.hourChanged = hourChanged;
		this.dayChanged = dayChanged;
		this.checkAllListeners();
		this.hourChanged = false;
		this.dayChanged = false;
	},
	formatGameTime(minutes) {
		const hours = Math.floor(minutes / 60);
		const mins = minutes % 60;
		return `${hours.toString().padStart(2, "0")}:${mins
			.toString()
			.padStart(2, "0")}`;
	},
	checkAllListeners() {
		this.listeners.forEach((listener) => {
			try {
				if (this.checkCondition(listener.condition)) {
					this.executeActions(listener.actions);
					if (listener.once) {
						this.removeListener(listener.id);
					}
				}
			} catch (e) {
				this.debugLog(`监听器检查失败:${listener.id}`, e);
			}
		});
	},
	beforeLoadNode() {
		// 健康检查（不再直接跳转）
		const currentHealth = this.getVariable("var.health");
		if (typeof currentHealth === "number" && currentHealth <= 0) {
			this.debugLog("健康值耗尽，触发死亡结局");
			this.setVariable("var.health", 100);
			return "ending_death"; // 仅返回节点ID，不执行跳转
		}

		// 监听器检查（仅返回跳转目标）
		const generalListeners = this.listeners.filter((l) => l.type !== "time");
		const jumpListener = generalListeners.find(
			(l) => l.nodeId && this.checkCondition(l.condition)
		);

		if (jumpListener) {
			this.executeActions(jumpListener.actions);
			if (jumpListener.once) {
				this.removeListener(jumpListener.id);
			}
			return jumpListener.nodeId; // 仅返回节点ID
		}

		// 执行其他监听器（不触发跳转）
		generalListeners.forEach((listener) => {
			if (this.checkCondition(listener.condition)) {
				this.executeActions(listener.actions);
				if (listener.once) {
					this.removeListener(listener.id);
				}
			}
		});

		return null;
	},
	validateSlotIndex(index) {
		return index >= 0 && index < this.saveSlots.length;
	},
	getSlotKey(index) {
		return `save_slot_${index}`;
	},
	loadSaveSlots() {
		[0, 1, 2, 3, 4].forEach((slotIndex) => {
			storage.get({
				key: this.getSlotKey(slotIndex),
				success: (data) => {
					if (data) {
						try {
							const saveData = JSON.parse(data);
							this.saveSlots[slotIndex].time = saveData.time;
						} catch (e) {
							this.saveSlots[slotIndex].time = "损坏存档";
						}
					}
				},
			});
		});
	},
	// 新增过滤方法
	filterTempVars(vars) {
		const filtered = { ...vars };
		delete filtered.temp;
		return filtered;
	},

	saveGameState() {
		const state = {
			vars: JSON.parse(JSON.stringify(this.filterTempVars(this.vars))),
			currentNodeId: this.currentNodeId,
			listeners: JSON.parse(JSON.stringify(this.listeners)),
		};
		storage.set({
			key: this.STORAGE_KEY,
			value: JSON.stringify(state),
			success: () => this.debugLog("游戏状态已保存"),
			fail: (code) => this.debugLog(`保存失败:code=${code}`),
		});
	},

	// 修改保存方法支持自动加载
	saveToSlot(slotIndex, autoLoad = false) {
		if (!this.validateSlotIndex(slotIndex)) return;
		const saveData = {
			time: this.getCurrentDateTime(),
			state: {
				vars: JSON.parse(JSON.stringify(this.filterTempVars(this.vars))),
				currentNodeId: this.currentNodeId,
				listeners: JSON.parse(JSON.stringify(this.listeners)),
			},
		};
		storage.set({
			key: this.getSlotKey(slotIndex),
			value: JSON.stringify(saveData),
			success: () => {
				this.saveSlots[slotIndex] = saveData;
				this.showToast(`存档${slotIndex + 1}成功`, 1000);
				// 新增自动加载逻辑
				if (autoLoad) {
					this.loadFromSlot(slotIndex);
				}
			},
			fail: () => this.showToast("存档失败", 1000),
		});
	},
	loadFromSlot(slotIndex) {
		slotIndex = Number(slotIndex);
		if (!this.validateSlotIndex(slotIndex)) return;
		storage.get({
			key: this.getSlotKey(slotIndex),
			success: (data) => {
				if (data) {
					try {
						const saveData = JSON.parse(data);
						this.vars = saveData.state.vars || {};
						this.currentNodeId = saveData.state.currentNodeId || "start";
						this.listeners = saveData.state.listeners || [];
						this.updateShowVars();
						this.loadNode(this.currentNodeId);
						this.showToast(`加载存档${slotIndex + 1}成功`, 1000);
					} catch (e) {
						this.showToast("存档损坏", 1500);
					}
				} else {
					this.showToast("无存档数据", 1000);
				}
				this.showMenu = false;
			},
			fail: () => {
				this.showToast("加载失败", 1000);
				this.showMenu = false;
			},
		});
	},
	deleteSaveSlot(slotIndex) {
		if (!this.validateSlotIndex(slotIndex)) return;
		storage.delete({
			key: this.getSlotKey(slotIndex),
			success: () => {
				this.saveSlots[slotIndex].time = "";
			},
			fail: () => this.debugLog("删除失败", 1000),
		});
	},
	validateLinkIndex(index) {
		return index >= 0 && index < this.currentLinks.length;
	},
	processLinkTarget(link) {
		let targetNode = link.target;
		if (link.random?.length > 0) {
			const validOptions = link.random.filter(
				(opt) => !opt.if || this.checkCondition(opt.if)
			);
			if (validOptions.length > 0) {
				const totalWeight = validOptions.reduce((sum, o) => sum + o.weight, 0);
				let randVal = Math.random() * totalWeight;
				for (const opt of validOptions) {
					randVal -= opt.weight;
					if (randVal <= 0) {
						targetNode = opt.target;
						if (opt.incom) this.processIncomingData(opt.incom);
						break;
					}
				}
			}
		}
		return targetNode;
	},
	processIncomingData(data) {
		Object.entries(data).forEach(([key, value]) => {
			try {
				const finalValue = this.resolveValue(value);
				this.setVariable(`var.temp.${key}`, finalValue);
			} catch (e) {
				this.setVariable(`var.temp.${key}`, value);
			}
		});
	},
	getCurrentTime() {
		const now = new Date();
		return `${now.getHours().toString().padStart(2, "0")}:${now
			.getMinutes()
			.toString()
			.padStart(2, "0")}`;
	},
	getCurrentDateTime() {
		const now = new Date();
		return (
			`${now.getFullYear()}-${(now.getMonth() + 1)
				.toString()
				.padStart(2, "0")}-${now.getDate().toString().padStart(2, "0")} ` +
			`${now.getHours().toString().padStart(2, "0")}:${now
				.getMinutes()
				.toString()
				.padStart(2, "0")}:${now.getSeconds().toString().padStart(2, "0")}`
		);
	},

	getFormattedTime() {
		const timeVar = this.getVariable("var.world.time");
		if (typeof timeVar !== "number") {
			return timeVar || "08:00";
		}
		const normalizedTime = ((timeVar % 1440) + 1440) % 1440;
		const hours = Math.floor(normalizedTime / 60);
		const minutes = normalizedTime % 60;
		return `${hours.toString().padStart(2, "0")}:${minutes
			.toString()
			.padStart(2, "0")}`;
	},
	getFullTimeInfo() {
		const day = this.getVariable("var.world.day") || 1;
		const time = this.getVariable("var.world.time") || 480;
		return {
			day,
			time,
			formatted: this.getFormattedTime(),
			period: this.getTimePeriod(time),
		};
	},
	getTimePeriod(time) {
		const hour = Math.floor(time / 60);
		if (hour < 5) return "深夜";
		if (hour < 8) return "凌晨";
		if (hour < 11) return "早晨";
		if (hour < 13) return "中午";
		if (hour < 17) return "下午";
		if (hour < 20) return "傍晚";
		return "夜晚";
	},
	debugLog(message) {
		if (this.debugMode) {
			this.showToast(`${message}`, 500);
		}
	},
	showToast(message, duration = 2000) {
		prompt.showToast({ message, duration });
	},
	handleError(context, error) {
		const msg = `${context}:${error.message || error}`;
		this.pushErrorSegment(msg);
		this.showToast(msg);
	},
	pushErrorSegment(message) {
		this.segments.push({ type: "error", content: message });
	},
};
</script>
<style>
.main-container {
	width: 212px;
	position: relative;
}

.content-scroll {
	width: 212px;
	padding: 0 28px 95px 28px;
	background-color: #000;
	flex-direction: column;
	align-items: center;
}

.header {
	width: 212px;
	height: 100px;
	align-items: center;
}

.time {
	top:-20px;
	width: 100%;
	font-size: 30px;
	font-weight: 600;
	text-align: center;
	display: flex;
	align-items: flex-end;
	color: rgba(255, 255, 255, 0.6);
}

.pagetitle {
	position: absolute;
	left: 0;
	top: 45px;
	width: 212px;
	height: 46px;
	font-size: 30px;
	font-weight: 600;
	text-align: center;
	color: rgba(255, 255, 255, 1);
}

.scene {
	width: 190px;
	padding: 4px;
	border-radius: 36px;
	background-color: #1a1a1a;
	flex-direction: row;
	flex-wrap: wrap;
}

.normal-text {
	font-size: 30px;
	color: #fff;
}

.link-container {
	width: 100%;
	flex-direction: row;
	justify-content: center;
	align-items: center;
	background-color: rgb(58, 127, 255);
	padding: 5px 10px;
	border-radius: 24px;
	margin-top: 10px;
}

.link-text {
	font-size: 30px;
	color: #fff;
}

.disabled-text {
	font-size: 30px;
	color: #777;
}

.error-text {
	font-size: 30px;
	color: #ff4d4f;
}

.sidebar-menu {
	top: 0;
	right: 0;
	width: 212px;

	align-items: flex-end;
	flex-direction: column;
	background-color: #1a1a1a;
}

.menu-header {
	width: 300px;
	flex-direction: row;
	justify-content: flex-end;
	align-items: center;
	padding: 10px 20px;
	background-color: #1a1a1a;
}

.menu-title {
	font-size: 30px;
	padding-right: 15px;
	font-weight: bold;
	color: #fff;
}

.menu-tabs {
	flex-direction: row;
	height: 60px;
	width: 200px;
	background-color: #1a1a1a;
	border-radius: 36px;
}

.menu-tab {
	flex: 1;
	height: 60px;
	text-align: center;
	font-size: 30px;
	color: #fff;
	background-color: #1a1a1a;
	border: none;
}

.active-tab {
	background-color: rgba(255, 255, 255, 0.06);
	color: #4a90e2;
	border-radius: 36px;
}

.tab-content-container {
	flex: 1;
	flex-direction: column;
}

.menu-scroll {
	flex: 1;
	padding: 10px;
	flex-direction: column;
	padding-bottom: 30px;
}

.status-section {
	flex-direction: row;
	justify-content: flex-end;
	padding: 4px 0;
}

.inventory-container {
	border: 2px solid rgba(74, 144, 226, 0.3);
	border-radius: 12px;
	padding: 10px;
	margin: 8px 0;
	background-color: rgba(0, 0, 0, 0.2);
	align-items: flex-end; /* 新增右对齐 */
}

.inventory-card {
	flex-direction: row;
	align-items: center;
	padding: 8px 15px 8px 8px; /* 调整左右padding */
	margin: 4px 0;
	background-color: rgba(255, 255, 255, 0.05);
	border-radius: 8px;
	border: 1px solid rgba(255, 255, 255, 0.1);
	justify-content: flex-end; /* 新增右对齐 */
	align-items: flex-end;
}

.inventory-title {
	font-size: 28px;
	color: #4a90e2;
	text-align: right; /* 新增右对齐 */
}

.inventory-item {
	font-size: 22px;
	color: #fff;
	margin-left: 0; /* 移除左边距 */
	margin-right: 8px; /* 新增右边距 */
	text-align: right; /* 新增右对齐 */
}

.empty-inventory {
	font-size: 20px;
	color: #666;
	text-align: right; /* 修改为右对齐 */
	padding: 10px;
	margin-right: 15px; /* 新增右边距 */
}

.save-section {
	flex-direction: column;
	padding: 5px;
}

.save-item {
	flex-direction: column;
	padding: 18px 10px;
	width: 240px;
	margin-bottom: 30px;
	border: 3px solid rgba(255, 255, 255, 0.06);
	background-color: rgba(255, 255, 255, 0.03);
	border-radius: 24px;
}

.save-header {
	flex-direction: column;
	justify-content: space-between;
	padding: 0 10px;
	margin-bottom: 8px;
}

.save-title {
	font-size: 28px;
	color: #fff;
}

.save-time {
	flex-direction: column;
}

.save-date {
	font-size: 20px;
	color: #999;
}

.save-time-part {
	font-size: 20px;
	color: #999;
}

.save-actions {
	flex-direction: row;
	justify-content: space-around;
}

.save-btn,
.load-btn,
.delete-btn {
	padding: 8px 15px;
	border-radius: 18px;
	font-size: 24px;
	color: #fff;
	border: 3px solid rgba(255, 255, 255, 0.06);
	background-color: rgba(255, 255, 255, 0.07);
}

.save-btn {
	color: #2ecc71;
	margin-right: 20px;
}

.load-btn {
	color: #3498db;
}

.delete-btn {
	color: #e74c3c;
}

.settings-section {
	flex: 1;
	flex-direction: column;
	padding: 15px;
}

.setting-item {
	flex-direction: row;
	justify-content: space-between;
	align-items: center;
	padding: 15px 0;
}

.menu-action {
	margin-top: 20px;
	padding: 15px;
	border: 3px solid rgba(255, 255, 255, 0.06);
	background-color: rgba(255, 255, 255, 0.07);
	border-radius: 24px;
	text-align: center;
}
</style>
